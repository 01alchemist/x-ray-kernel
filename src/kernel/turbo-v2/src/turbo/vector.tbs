class Vector {
    x: float32;
    y: float32;
    z: float32;

    constructor(x: float32, y: float32, z: float32): Vector {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }

    length(): float32 {
        return Math.sqrt((this.x * this.x) + (this.y * this.y) + (this.z * this.z));
    }

    lengthN(n: float32): float32 {
        if (n == 2) {
            return this.length();
        }
        a = this.abs();
        return Math.pow(Math.pow(this.x, n) + Math.pow(this.y, n) + Math.pow(this.z, n), 1 / n);
    }

    dot(b: Vector): float32 {
        return (this.x * b.x) + (this.y * b.y) + (this.z * b.z);
    }

    cross(b: Vector): Vector {
        return new Vector((this.y * b.z) - (this.z * b.y), (this.z * b.x) - (this.x * b.z), (this.x * b.y) - (this.y * b.x));
    }

    normalize(): Vector {
        let d: float32 = this.length();
        return new Vector(this.x / d, this.y / d, this.z / d);
    }

    negate(): Vector {
        return new Vector(-this.x, -this.y, -this.z);
    }

    abs(): Vector {
        return new Vector(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));
    }

    add(b: Vector): Vector {
        return new Vector(this.x + b.x, this.y + b.y, this.z + b.z);
    }

    sub(b: Vector): Vector {
        return new Vector(this.x - b.x, this.y - b.y, this.z - b.z);
    }

    mul(b: Vector): Vector {
        return new Vector(this.x * b.x, this.y * b.y, this.z * b.z);
    }

    div(b: Vector): Vector {
        return new Vector(this.x / b.x, this.y / b.y, this.z / b.z);
    }

    mod(b: Vector): Vector { // as implemented in GLSL
        return new Vector(this.x - b.x * Math.floor(this.x / b.x), this.y - b.y * Math.floor(this.y / b.y), this.z - b.z * Math.floor(this.z / b.z));
    }

    addScalar(f: float32): Vector {
        return new Vector(this.x + f, this.y + f, this.z + f);
    }

    subScalar(f: float32): Vector {
        return new Vector(this.x - f, this.y - f, this.z - f);
    }

    mulScalar(f: float32): Vector {
        return new Vector(this.x * f, this.y * f, this.z * f);
    }

    divScalar(f: float32): Vector {
        return new Vector(this.x / f, this.y / f, this.z / f);
    }

    min(b: Vector): Vector {
        return new Vector(Math.min(this.x, b.x), Math.min(this.y, b.y), Math.min(this.z, b.z));
    }

    max(b: Vector): Vector {
        return new Vector(Math.max(this.x, b.x), Math.max(this.y, b.y), Math.max(this.z, b.z));
    }

    minAxis(a: Vector): Vector {
        let x: float32 = Math.abs(this.x);
        let y: float32 = Math.abs(this.y);
        let z: float32 = Math.abs(this.z);
        if (x <= y && x <= z) {
            return new Vector(1, 0, 0);
        } else if (y <= x && y <= z) {
            return new Vector(0, 1, 0);
        }
        return new Vector(0, 0, 1);
    }

    minComponent(a: Vector): float32 {
        return Math.min(Math.min(this.x, this.y), this.z);
    }

    maxComponent(a: Vector): float32 {
        return Math.max(Math.max(this.x, this.y), this.z);
    }

    reflect(b: Vector): Vector {
        return b.sub(this.mulScalar(2.0 * this.dot(b)));
        //return Vector.Sub(b, Vector.MulScalar(a, 2 * Vector.Dot(a,b)));
    }

    refract(b: Vector, n1: float32, n2: float32): Vector {
        let nr: float32 = n1 / n2;
        let cosI: float32 = -this.dot(b);
        let sinT2: float32 = nr * nr * (1 - cosI * cosI);
        if (sinT2 > 1) {
            return new Vector(0.0, 0.0, 0.0);
        }
        let cosT: float32 = Math.sqrt(1.0 - sinT2);
        return b.mulScalar(nr).add(this.mulScalar(nr * (cosI - cosT)));
// return Vector.Add(Vector.MulScalar(b, nr), Vector.MulScalar(a, nr * cosI - cosT));
    }

    reflectance(b: Vector, n1: float32, n2: float32): float32 {
        let nr: float32 = n1 / n2;
        let cosI: float32 = -this.dot(b);
        let sinT2: float32 = nr * nr * (1 - cosI * cosI);
        if (sinT2 > 1) {
            return 1;
        }
        let cosT: float32 = Math.sqrt(1 - sinT2);
        let rOrth: float32 = (n1 * cosI - n2 * cosT) / (n1 * cosI + n2 * cosT);
        let rPar: float32 = (n2 * cosI - n1 * cosT) / (n2 * cosI + n1 * cosT);
        return (rOrth * rOrth + rPar * rPar) / 2;
    } //-------------------------------- // x x x x x x x x x x x x x x x x //--------------------------------
    pow(f: float32): Vector {
        return new Vector(Math.pow(this.x, f), Math.pow(this.y, f), Math.pow(this.z, f));
    }

    isEqual(b: Vector): boolean {
        return this.x == b.x && this.y == b.y && this.z == b.z;
    }

    isZero(): boolean {
        return this.x == 0.0 && this.y == 0.0 && this.z == 0.0;
    }

    set(x: float32, y: float32, z: float32): Vector {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }

    setFromVector(d: Vector): Vector {
        this.x = d.x;
        this.y = d.y;
        this.z = d.z;
        return this;
    }

    // setFromArray(d:float32[]) {
// this.x = d[0];
// this.y = d[1];
// this.z = d[2];
// return this;
// }
    copy(src: Vector): Vector {
        return this.set(src.x, src.y, src.z);
    }

    clone(): Vector {
        return new Vector(this.x, this.y, this.z);
    }
}
function RandomUnitVector(): float32 {
    let x = Math.random() * 2.0 - 1.0;
    let y = Math.random() * 2.0 - 1.0;
    let z = Math.random() * 2.0 - 1.0;
    while (x * x + y * y + z * z > 1.0) {
        x = Math.random() * 2.0 - 1.0;
        y = Math.random() * 2.0 - 1.0;
        z = Math.random() * 2.0 - 1.0;
    }
    let vec: Vector = new Vector(x, y, z);
    let vecN = vec.normalize();
    delete vec;
    return vecN;
}
const ZERO: Vector = new Vector(0.0, 0.0, 0.0);
const ONE: Vector = new Vector(1.0, 1.0, 1.0);
const NegativeONE: Vector = new Vector(-1, -1, -1);