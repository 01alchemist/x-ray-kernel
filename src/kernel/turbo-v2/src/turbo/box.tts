class Box{
	
	min:Vector3;
	max:Vector3;

	constructor(min:Vector3, max:Vector3):Box {
        this.min = min?min:new Vector3();
        this.max = max?max:new Vector3();
        return this;
	}

    set(min:Vector3, max:Vector3):Box {
        this.min = min;
        this.max = max;
        return this;
	}

    // static ToJSON(this){
     //    return {
     //        min:Vector3.ToJSON(this.min),
     //        max:Vector3.ToJSON(this.max)
     //    };
	// }

	static boxForShapes(shapes:Shape[], numShapes:number):number{
		if(numShapes == 0) {
			return new Box();
		}
		// let box = Shape.BoundingBox(Shape.Array.at(shapes, 0));
		let box = new Box();

		for(let i:number = 0; i < numShapes; i++){
			let shape:Shape = shapes[i];
			box = box.extend(shape.boundingBox);
		}
		return box;
	}

	// static BoxForTriangles(shapes:number, numShapes:number):number {
     //    if(numShapes == 0) {
     //        return Box.NewBox();
     //    }
     //    let box = Triangle.BoundingBox(Triangle.Array.at(shapes, 0));
    //
     //    for(let i:number = 0; i < numShapes; i++){
     //        let shape:number = Triangle.Array.at(shapes, i);
     //        box = Box.Extend(box, Triangle.BoundingBox(shape));
     //    }
     //    return box
	// }

	static Anchor_mem(anchor:number, c?:number):number {
        let size = Box.Size_mem(this);
        let tmp = Vector3.Mul_mem(size, anchor);
        free(size);
        if(c){
            free(tmp);
        }else{
            c = tmp;
        }
		return Vector3.Add_mem(this.min, c, c);
    }
	static Anchor(anchor:Vector3):number {
        let size:Vector3 = Box.Size(this);
		return Vector3.Add_12(this.min, size.mul(anchor));
    }

	static Center_mem(this):number {
        let anchor = Vector3.NewVector(0.5, 0.5, 0.5);
		return Box.Anchor(anchor, anchor);
	}
	static Center(this):Vector3 {
        let anchor = new Vector3(0.5, 0.5, 0.5);
		return Box.Anchor(anchor);
	}

	static OuterRadius(this):number {
        let center:Vector3 = Box.Center(this);
        return Vector3.Sub_12(this.min, center).length();
	}

	static InnerRadius(this):number {
        let center = Box.Center(this);
        return Vector3.Sub_21(center, this.min).maxComponent();
    }

	static Size_mem(this):number {
		return Vector3.Sub_mem(this.max, this.min);
	}
	static Size(this):Vector3 {
		return Vector3.Sub_mem_2(this.max, this.min);
	}

	static Extend(b:number):number{
        //let ptr:number = @new Box;
		let min = this.min;
		let max = this.max;
		let bmin = Box.min(b);
		let bmax = Box.max(b);
		return Box.Init_mem(Vector3.Min_mem(min, bmin, min), Vector3.Max_mem(max, bmax, max));
	}

	static Contains(this , b:number):boolean{

        let a_min = this.min;
        let a_max = this.max;

		return Vector3.x(a_min) <= Vector3.x(b) && Vector3.x(a_max) >= Vector3.x(b) &&
			Vector3.y(a_min) <= Vector3.y(b) && Vector3.y(a_max) >= Vector3.y(b) &&
			Vector3.z(a_min) <= Vector3.z(b) && Vector3.z(a_max) >= Vector3.z(b);
	}

	static Intersects(a:number, b:number):boolean {
        let a_min = Box.min(a);
        let a_max = Box.max(a);
        let b_min = Box.min(b);
        let b_max = Box.max(b);

		return !(Vector3.x(a_min) > Vector3.x(b_max) || Vector3.x(a_max) < Vector3.x(b_min) || Vector3.y(a_min) > Vector3.y(b_max) ||
		Vector3.y(a_max) < Vector3.y(b_min) || Vector3.z(a_min) > Vector3.z(b_max) || Vector3.z(a_max) < Vector3.z(b_min));
	}

	static Intersect(r:Ray):{tmax:number, tmin:number} {

        let min = this.min;
        let max = this.max;

        // x1 := (b.min.x - r.Origin.x) / r.Direction.x
        // y1 := (b.min.y - r.Origin.y) / r.Direction.y
        // z1 := (b.min.z - r.Origin.z) / r.Direction.z
        // x2 := (b.max.x - r.Origin.x) / r.Direction.x
        // y2 := (b.max.y - r.Origin.y) / r.Direction.y
        // z2 := (b.max.z - r.Origin.z) / r.Direction.z

		let x1 = (Vector3.x(min) - r.origin.x) / r.direction.x;
        let y1 = (Vector3.y(min) - r.origin.y) / r.direction.y;
        let z1 = (Vector3.z(min) - r.origin.z) / r.direction.z;
        let x2 = (Vector3.x(max) - r.origin.x) / r.direction.x;
        let y2 = (Vector3.y(max) - r.origin.y) / r.direction.y;
        let z2 = (Vector3.z(max) - r.origin.z) / r.direction.z;
        let tmp;

		if (x1 > x2) {
            tmp = x1;
			x1 = x2;
            x2 = tmp;
		}
		if (y1 > y2) {
			tmp = y1;
			y1 = y2;
            y2 = tmp
		}
		if (z1 > z2) {
            tmp = z1;
            z1 = z2;
            z2 = tmp
		}
		return {
            tmin: Math.max(Math.max(x1, y1), z1),
		    tmax: Math.min(Math.min(x2, y2), z2)
        };
	}

	static Partition(axis:Axis, point:number): {left:boolean, right:boolean} {
        let min = this.min;
        let max = this.max;
        let left;
        let right;
		switch (axis) {
			case Axis.AxisX:
				left = Vector3.x(min) <= point;
				right = Vector3.x(max) >= point;
                break;
			case Axis.AxisY:
				left = Vector3.y(min) <= point;
				right = Vector3.y(max) >= point;
                break;
            case Axis.AxisZ:
				left = Vector3.z(min) <= point;
				right = Vector3.z(max) >= point;// EPIC Bug :D it was min and got weird triangle intersection
                break;
		}
		return {
            left :left,
            right:right
        };
	}

} @end

