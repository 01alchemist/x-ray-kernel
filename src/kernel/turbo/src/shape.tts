interface Hit{
    Shape:number;
}
interface Ray{

}

export enum ShapeType{
    Volume,
    SDFShape
}

@turbo class Shape{

    shapeId:uint32

	@method init(SELF:number, id):number{
        SELF.shapeId = id;
		return SELF;
	}

	@virtual Compile(SELF:number, s:number){
		throw "Pure: Shape.Compile()";
	}

	@virtual BoundingBox(SELF:number, s:number):number{
		throw "Pure: Shape.BoundingBox()";
	}

	@virtual Intersect(SELF:number, s:number, ray:Ray):Hit{
		throw "Pure: Shape.Intersect()";
	}

	@virtual UV(SELF:number, s:number, p:number):number{
		throw "Pure: Shape.UV()";
	}

	@virtual NormalAt(SELF:number, s:number, p:number):number{
		throw "Pure: Shape.NormalAt()";
	}

	@virtual MaterialAt(SELF:number, s:number, p:number):number{
		throw "Pure: Shape.MaterialAt()";
	}

} @end

@turbo class TransformedShape{

	Shape:int32
	Matrix:Matrix
	Inverse:Matrix

	@method init(SELF:number, shape:number){
        SELF.Shape = shape;
		return SELF;
	}

	static NewTransformedShape(s:number, m:number):number {
		return TransformedShape.init(@new TransformedShape, s, m, Matrix.Inverse(m));
	}

	static BoundingBox(s:TransformedShape):Box {
		return Matrix.MulBox(s, Shape.BoundingBox(s));
	}

	static Intersect(s:number, r:Ray):Hit {
		let shapeRay = Matrix.MulRay(TransformedShape.Inverse(s), r);
		let hit = Shape.Intersect(s, shapeRay);
		if (!hit.Ok()) {
			return hit;
		}
		let shape:number = hit.Shape;
		let shapePosition = Ray.Position(shapeRay, hit.T);
		let shapeNormal = Shape.NormalAt(shape, shapePosition);
		let position = Matrix.MulPosition(s, shapePosition);
		let normal = Matrix.MulDirection(Matrix.Transpose(Matrix.Inverse(s)), shapeNormal);
		let material = Material.MaterialAt(shape, shapePosition);
		let inside = false;
		if (shapeNormal.Dot(shapeRay.Direction) > 0) {
			Vector.Negate_mem(normal, normal);
			inside = true;
		}
		let ray:number = @new Ray;
        Ray.init(ray, position, normal);
		let info = new HitInfo(shape, position, normal, ray, material, inside);
		hit.T = Vector.Length(Vector.Sub_mem(position, Ray.Origin(r)));
		hit.HitInfo = info;
		return hit;
	}

} @end