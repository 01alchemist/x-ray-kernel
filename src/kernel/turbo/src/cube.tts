@turbo class Cube extends Shape{
	Min:Vector
	Max:Vector
	Material:Material
	Box:Box

	@method init(SELF, min, max, material, box){
        SELF.Min = min;
        SELF.Max = max;
        SELF.Material = material;
        SELF.Box = box;
        return SELF;
    }
    static NewCube(min, max, material):number {
        let box = Box.Init_mem(@new  Box, min, max);
        return Cube.init(@new Cube, min, max, material, box);
    }

    @virtual Type(SELF:number){
        throw ShapeType.CUBE;
    }

    @virtual ToJSON(SELF){
        return {
            min:Vector.ToJSON(SELF.Min),
            max:Vector.ToJSON(SELF.Max),
            material:Material.ToJSON(SELF.Material),
            box:Box.ToJSON(SELF.Box),
        }
    }

    @virtual Compile(SELF){
    }

    @virtual BoundingBox(SELF):number {
        return SELF.Box;
    }

    @virtual Intersect(SELF, r:number):Hit {
        let n = Vector.Div_mem(Vector.Sub_mem(SELF.Min, Ray.Origin(r)), Ray.Direction(r));
        let f = Vector.Div_mem(Vector.Sub_mem(SELF.Max, Ray.Origin(r)), Ray.Direction(r));
        let _n = Vector.Min_mem(n, f);
        let _f = Vector.Max_mem(n, f);
        let t0 = Math.max(Math.max(Vector.X(_n), Vector.Y(_n)), Vector.Z(_n));
        let t1 = Math.min(Math.min(Vector.X(_f), Vector.Y(_f)), Vector.Z(_f));
        if (t0 > 0 && t0 < t1) {
            return new Hit(SELF, t0, null)
        }
        return Hit.NoHit;
    }

    @virtual UV(SELF, p):number {
        Vector.Div_mem(Vector.Sub_mem(p, SELF.Min, p), Vector.Sub_mem(SELF.Max, SELF.Min), p);
        return Vector.NewVector(Vector.X(p), Vector.Z(p), 0);
    }

    @virtual MaterialAt(SELF, p:number):number {
        return SELF.Material;
    }

    @virtual NormalAt(SELF, p):number {

        let min = SELF.Min;
        let max = SELF.Max;

        if(Vector.X(p) < Vector.X(min)+EPS)
            return Vector.NewVector(-1, 0, 0);
        else if(Vector.X(p) > Vector.X(max)-EPS)
            return Vector.NewVector(1, 0, 0);
        else if (Vector.Y(p) < Vector.Y(min)+EPS)
            return Vector.NewVector(0, -1, 0);
        else if (Vector.Y(p) > Vector.Y(max)-EPS)
            return Vector.NewVector(0, 1, 0);
        else if (Vector.Z(p) < Vector.Z(min)+EPS)
            return Vector.NewVector(0, 0, -1);
        else if (Vector.Z(p) > Vector.Z(max)-EPS)
            return Vector.NewVector(0, 0, 1);

        return Vector.NewVector(0, 1, 0);
    }

    static Mesh(SELF):number {
        let a = SELF.Min;
        let b = SELF.Max;
        let z = Vector.NewVector();
        let m = SELF.Material;
        let v000 = Vector.NewVector(Vector.X(a), Vector.Y(a), Vector.Z(a));
        let v001 = Vector.NewVector(Vector.X(a), Vector.Y(a), Vector.Z(b));
        let v010 = Vector.NewVector(Vector.X(a), Vector.Y(b), Vector.Z(a));
        let v011 = Vector.NewVector(Vector.X(a), Vector.Y(b), Vector.Z(b));
        let v100 = Vector.NewVector(Vector.X(b), Vector.Y(a), Vector.Z(a));
        let v101 = Vector.NewVector(Vector.X(b), Vector.Y(a), Vector.Z(b));
        let v110 = Vector.NewVector(Vector.X(b), Vector.Y(b), Vector.Z(a));
        let v111 = Vector.NewVector(Vector.X(b), Vector.Y(b), Vector.Z(b));
        let triangles = [
            Triangle.NewTriangle(v000, v100, v110, z, z, z, m),
            Triangle.NewTriangle(v000, v110, v010, z, z, z, m),
            Triangle.NewTriangle(v001, v101, v111, z, z, z, m),
            Triangle.NewTriangle(v001, v111, v011, z, z, z, m),
            Triangle.NewTriangle(v000, v100, v101, z, z, z, m),
            Triangle.NewTriangle(v000, v101, v001, z, z, z, m),
            Triangle.NewTriangle(v010, v110, v111, z, z, z, m),
            Triangle.NewTriangle(v010, v111, v011, z, z, z, m),
            Triangle.NewTriangle(v000, v010, v011, z, z, z, m),
            Triangle.NewTriangle(v000, v011, v001, z, z, z, m),
            Triangle.NewTriangle(v100, v110, v111, z, z, z, m),
            Triangle.NewTriangle(v100, v111, v101, z, z, z, m)
        ];
        return Mesh.NewMesh(Triangle.Pack(triangles));
    }
} @end
