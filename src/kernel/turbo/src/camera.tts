@turbo class Camera {
	p:Vector
	u:Vector
	v:Vector
	w:Vector
	m:float64
	focalDistance :float64
	apertureRadius:float64

    @method init(SELF, p:number, u:number, v:number, w:number, m:number, focalDistance:number=0, apertureRadius:number=0){
        SELF.p = p;
        SELF.u = u;
        SELF.v = v;
        SELF.w = w;
        SELF.m = m;
        SELF.focalDistance = focalDistance;
        SELF.apertureRadius = apertureRadius;
        return SELF;
    }

    static NewCamera(p:number, u?:number, v?:number, w?:number, m?:number, focalDistance?:number, apertureRadius?:number){
        let ptr:number = @new Camera;
        p = p?p:Vector.NewVector();
        u = u?u:Vector.NewVector();
        v = v?v:Vector.NewVector();
        w = w?w:Vector.NewVector();
        m = m?m:Vector.NewVector();
        return Camera.init(ptr, p, u, v, w, m, focalDistance, apertureRadius);
    }

    static ToJSON(SELF){
        return {
            p:Vector.XYZ(SELF.p),
            u:Vector.XYZ(SELF.u),
            v:Vector.XYZ(SELF.v),
            w:Vector.XYZ(SELF.w),
            m:SELF.m,
            focalDistance:SELF.focalDistance,
            apertureRadius:SELF.apertureRadius
        };
    }

    static LookAt(eye, center, up, fovy:number, c?:number):number {
        c = c?c:@new Camera;
        Camera.init(c);
        Camera.p(c) = eye;
        let w:number = Vector.Normalize_mem(Vector.Sub_mem(center, eye));
        Camera.w(c) = w;
        let u:number = Vector.Normalize_mem(Vector.Cross_mem(up, w));
        Camera.u(c) = u;
        Camera.v(c) = Vector.Normalize_mem(Vector.Cross_mem(w, u));
        Camera.m(c) = 1 / Math.tan(fovy*Math.PI/360);
        return c;
    }

    static SetFocus(c:number, focalPoint:number, apertureRadius:number) {
        Camera.focalDistance(c) = Vector.Length_mem(Vector.Sub_mem(focalPoint, Camera.p(c)));
        Camera.apertureRadius(c) = apertureRadius;
    }

    static CastRay(c:number, x:number, y:number, w:number, h:number, u:number, v:number):number {
        let aspect = w / h;
        let px = ((x+u-0.5)/(w-1))*2 - 1;
        let py = ((y+v-0.5)/(h-1))*2 - 1;
        let d = @new Vector;
        d = Vector.Add_mem(d, Vector.MulScalar_mem(Camera.u(c), -px * aspect), d);
        d = Vector.Add_mem(d, Vector.MulScalar_mem(Camera.v(c), -py), d);
        d = Vector.Add_mem(d, Vector.MulScalar_mem(Camera.w(c), Camera.m(c)), d);
        d = Vector.Normalize_mem(d, d);
        let p = Camera.p(c);
        if (Camera.apertureRadius(c) > 0) {
            let focalPoint = Vector.Add_mem(Camera.p(c), Vector.MulScalar_mem(d, Camera.focalDistance(c)));
            let angle = Math.random() * 2 * Math.PI;
            let radius = Math.random() * Camera.apertureRadius(c);
            p = Vector.Add_mem(p, Vector.MulScalar_mem(Camera.u(c), Math.cos(angle) * radius), p);
            p = Vector.Add_mem(p, Vector.MulScalar_mem(Vector.MulScalar_mem(Camera.v(c), Math.sin(angle) * radius), p));
            d = Vector.Normalize_mem(Vector.Sub_mem(focalPoint, p))
        }
        let ptr:number = @new Ray;
        return Ray.init(ptr, p, d);
    }

} @end