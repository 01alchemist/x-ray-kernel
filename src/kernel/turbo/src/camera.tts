@turbo class Camera {
	p:Vector
	u:Vector
	v:Vector
	w:Vector
	m:float64
	focalDistance :float64
	apertureRadius:float64

    @method init(SELF, p:number, u:number, v:number, w:number, m:number, focalDistance:number, apertureRadius:number){
        SELF.p = p;
        SELF.u = u;
        SELF.v = v;
        SELF.w = w;
        SELF.m = m;
        SELF.focalDistance = focalDistance;
        SELF.apertureRadius = apertureRadius;
    }
    static LookAt(eye, center, up, fovy:number, c?:number):number {
        c = c?c:@new Camera;
        Camera.init(c);
        Camera.p(c) = eye;
        let w:number = Vector.Normalize_mem(Vector.Sub_mem(center, eye));
        Camera.w(c) = w;
        let u:number = Vector.Normalize_mem(Vector.Cross_mem(up, w));
        Camera.u(c) = u;
        Camera.v(c) = Vector.Normalize_mem(Vector.Cross_mem(w, u));
        Camera.m(c) = 1 / Math.tan(fovy*Math.PI/360);
        return c;
    }

    static SetFocus(c:number, focalPoint:number, apertureRadius:number) {
        Camera.focalDistance(c) = Vector.Length_mem(Vector.Sub_mem(focalPoint, Camera.p(c)));
        Camera.apertureRadius(c) = apertureRadius;
    }

    static CastRay(c:number, x:number, y:number, w:number, h:number, u:number, v:number):number {
        let aspect = float64(w) / float64(h);
        let px = ((float64(x)+u-0.5)/(float64(w)-1))*2 - 1;
        let py = ((float64(y)+v-0.5)/(float64(h)-1))*2 - 1;
        let d = @new Vector;
        d = Vector.Add_mem(d, Vector.MulScalar_mem(Camera.u(c), -px * aspect), d);
        d = Vector.Add_mem(d, Vector.MulScalar_mem(Camera.v(c), -py), d);
        d = Vector.Add_mem(d, Vector.MulScalar_mem(Camera.w(c), Camera.m(c)), d);
        d = Vector.Normalize_mem(d);
        let p = Camera.p(c);
        if (Camera.apertureRadius(c) > 0) {
            let focalPoint = Vector.Add_mem(Camera.p(c), Vector.MulScalar_mem(d, Camera.focalDistance(c)));
            let angle = Math.random() * 2 * Math.PI;
            let radius = Math.random() * Camera.apertureRadius(c);
            p = Vector.Add_mem(p, Vector.MulScalar_mem(Camera.u(c), Math.cos(angle) * radius), p);
            p = Vector.Add_mem(p, Vector.MulScalar_mem(Vector.MulScalar_mem(Camera.v(c), Math.sin(angle) * radius), p);
            d = Vector.Normalize_mem(Vector.Sub_mem(focalPoint, p))
        }
        let ptr:number = @new Ray;
        return Ray.init(ptr, p, d);
    }

}