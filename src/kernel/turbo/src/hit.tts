export class Hit{

	static NoHit:Hit = new Hit(null, Number.POSITIVE_INFINITY, null);

	constructor(public Shape:number, public T:number, public HitInfo:HitInfo){

	}

	Ok():boolean{
		return this.T < Number.POSITIVE_INFINITY;
	}

	Info(r:number/*:Ray*/){
		if(this.HitInfo != null){
			return this.HitInfo;
		}

		let shape:number = this.Shape;
		let position:number = Ray.Position(r, this.T);
		let normal:number = Shape.NormalAt(this.Shape, position);
		let material:number = Material.MaterialAt(shape, position);
		let inside:boolean = false;

		if(Vector.Dot_mem(normal, Ray.Direction(r)) > 0){
			Vector.Negate_mem(normal, normal);
			inside = true;
			switch (Shape.Type(shape)) {
				case ShapeType.Volume:
				case ShapeType.SDFShape:
					inside = false;
					break;
			}
		}

		let ptr:number = @new Ray;
		let ray = Ray.init(ptr, position, normal);
		return new HitInfo(shape, position, normal, ray, material, inside);
	}
}

export class HitInfo{

	constructor(public Shape:number, //Shape
				public Position:number, //Vector
                public Normal:number, //Vector
                public Ray:number, //Ray
                public Material:number, //Material
                public Inside:boolean){

	}
}