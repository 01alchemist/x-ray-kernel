@turbo class Plane extends Shape{
    Point:Vector
	Normal:Vector
	Material:Material
    Box:Box
    HasBox:uint8

	@method init(SELF, point, normal, material){
        SELF.Point = point;
        SELF.Normal = normal;
        SELF.Material = material;
        SELF.Box = 0;
        SELF.HasBox = 0;
        return SELF;
    }

    static NewPlane(point:number, normal:number, material:number):number {
        Vector.Normalize_mem(normal, normal);
        let ptr:number = @new Plane;
        return Plane.init(ptr, point, normal, material);
    }

    @virtual Type(SELF:number){
        return ShapeType.PLANE;
    }

    @virtual ToJSON(SELF){
        return {
            point:Vector.ToJSON(SELF.Point),
            normal:Vector.ToJSON(SELF.Normal),
            material:Material.ToJSON(SELF.Material),
            box:Box.ToJSON(SELF.Box)
        }
    }

    @virtual Compile(SELF) {
    }

    @virtual BoundingBox(SELF):number {
        if(SELF.HasBox){
            return SELF.Box;
        }
        let ptr:number = @new Box;
        let inf = Number.POSITIVE_INFINITY;
        SELF.Box = Box.init(ptr, Vector.NewVector(-inf,-inf,-inf), Vector.NewVector(inf,inf,inf));
        SELF.HasBox = 1;
        return ptr;
    }

    @virtual Intersect(SELF, ray:Ray):Hit {
        let d = Vector.Dot_12(SELF.Normal, ray.direction);
        if (Math.abs(d) < EPS) {
            return Hit.NoHit;
        }
        let a:Vector3 = Vector.Sub_12(SELF.Point, ray.origin);
        let t:number = Vector.Dot_12(SELF.Normal, a) / d;
        if (t < EPS) {
            return Hit.NoHit;
        }
        return new Hit(SELF, t);
    }

    @virtual UV(SELF, a:Vector3):Vector3 {
        return new Vector3();
    }

    @virtual MaterialAt(SELF, a:Vector3):number {
        return SELF.Material;
    }

    @virtual NormalAt(SELF, a:Vector3):number {
        return new Vector3().read(SELF.Normal);
    }

} @end