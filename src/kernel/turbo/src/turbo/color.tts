type RGBA  = {
    r:number,
    g:number,
    b:number,
    A:number
};
type RGB = {
    r:number,
    g:number,
    b:number
};

@turbo class Color{

	r:float64
	g:float64
	b:float64

	@method init(SELF:number, color = {r:0,g:0,b:0}):number {
		SELF.r = color.r;
		SELF.g = color.g;
		SELF.b = color.b;
		return SELF;
	}

    static Init_mem(SELF:number, r:number = 0,g:number = 0,b:number = 0):number {
		SELF.r = r;
		SELF.g = g;
		SELF.b = b;
		return SELF;
	}

    static NewColor(color?,g:number = 0,b:number = 0):number {
        let ptr:number = @new Color;
        if(typeof color === "object"){
            return Color.init(ptr, color);
        }else{
            return Color.Init_mem(ptr, color, g, b);
        }
    }
    
	static HexColor(hex:number, c?):number {
		let r = ((hex >> 16) & 255 ) / 255;
		let g = ((hex >> 8) & 255) / 255;
		let b = (hex & 255) / 255;
        let ptr:number = c?c:@new Color;
		return Color.Pow_mem(Color.Init_mem(ptr, r, g, b), 2.2);
	}

    static Kelvin(K:number):number {
        var red:number;
        var green:number;
        var blue:number;
        // red
        if(K >= 6600){
            var A = 351.97690566805693;
            var b = 0.114206453784165;
            var c = -40.25366309332127;
            var x = K/100 - 55;
            red = A + b*x + c*Math.log(x)
        } else {
            red = 255;
        }
        // green
        if(K >= 6600){
            A = 325.4494125711974;
            b = 0.07943456536662342;
            c = -28.0852963507957;
            x = K/100 - 50;
            green = A + b*x + c*Math.log(x)
        } else if (K >= 1000) {
            A = -155.25485562709179;
            b = -0.44596950469579133;
            c = 104.49216199393888;
            x = K/100 - 2;
            green = A + b*x + c*Math.log(x)
        } else {
            green = 0
        }
        // blue
        if (K >= 6600) {
            blue = 255
        } else if (K >= 2000) {
            A = -254.76935184120902;
            b = 0.8274096064007395;
            c = 115.67994401066147;
            x = K/100 - 10;
            blue = A + b*x + c*Math.log(x)
        } else {
            blue = 0
        }
        red = Math.min(1, red/255);
        green = Math.min(1, green/255);
        blue = Math.min(1, blue/255);
        let ptr:number = @new Color;
        return Color.Init_mem(ptr, red, green, blue);
    }

    static FloatRGBA(SELF:number):RGBA {
        return {
            r: Color.r(SELF),
            g: Color.g(SELF),
            b: Color.b(SELF),
            A: 1.0
        };
    }

    static RGB(SELF:number):RGB {
        let _d:Uint8ClampedArray = new Uint8ClampedArray([
            Color.r(SELF) * 255,
            Color.g(SELF) * 255,
            Color.b(SELF) * 255
        ]);
        return rgb(_d[0], _d[1], _d[2]);
    }

    static RGBA(SELF:number):RGBA {
        let _d:Uint8ClampedArray = new Uint8ClampedArray([
            Color.r(SELF) * 255,
            Color.g(SELF) * 255,
            Color.b(SELF) * 255
        ]);
        return {
            r: _d[0],
            g: _d[1],
            b: _d[2],
            A: 255
        };
    }

    static RGBA64(SELF:number):RGBA {
        return {
            r: Math.round(Math.max(0, Math.min(65535, Color.r(SELF) * 65535))),
            g: Math.round(Math.max(0, Math.min(65535, Color.g(SELF) * 65535))),
            b: Math.round(Math.max(0, Math.min(65535, Color.b(SELF) * 65535))),
            A: 65535
        };
    }
    
    static Add(A:RGBA, b:RGBA):RGB { return rgb(A.r + b.r, A.g + b.g, A.b + b.b); }

    /**
     *
     * @param A Color 1
     * @param b Color 2
     * @param C result Color
     * @returns {number}
     * @constructor
     */
    static Add_mem(A:number, b:number, C?:number):number {
        if(C){
            Color.r(C) = Color.r(A) + Color.r(b);
            Color.g(C) = Color.g(A) + Color.g(b);
            Color.b(C) = Color.b(A) + Color.b(b);
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Color.r(A) + Color.r(b),
                Color.g(A) + Color.g(b),
                Color.b(A) + Color.b(b)
            );
        }
    }

    static Sub(A:RGBA, b:RGBA):RGB { return rgb(A.r - b.r, A.g - b.g, A.b - b.b); }
    static Sub_mem(A:number, b:number, C?:number):number {
        if(C){
            Color.r(C) = Color.r(A) - Color.r(b);
            Color.g(C) = Color.g(A) - Color.g(b);
            Color.b(C) = Color.b(A) - Color.b(b);
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Color.r(A) - Color.r(b),
                Color.g(A) - Color.g(b),
                Color.b(A) - Color.b(b)
            );
        }
    }
    
    static Mul(A:RGBA, b:Color3):RGB { return rgb(A.r * b.r, A.g * b.g, A.b * b.b); }
    static Mul2(A:number, b:Color3):Color3 {
        return new Color3(
            Color.r(A) * b.r,
            Color.g(A) * b.g,
            Color.b(A) * b.b
        );
    }
    static Mul_mem(A:number, b:number, C?:number):number {
        if(C){
            Color.r(C) = Color.r(A) * Color.r(b);
            Color.g(C) = Color.g(A) * Color.g(b);
            Color.b(C) = Color.b(A) * Color.b(b);
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Color.r(A) * Color.r(b),
                Color.g(A) * Color.g(b),
                Color.b(A) * Color.b(b)
            );
        }
    }

    static MulScalar(A:RGBA, f:number):RGB { return rgb(A.r * f, A.g * f, A.b * f); }
    static MulScalar2(A:number, f:number):Color3 {
        return new Color3(
            Color.r(A) * f,
            Color.g(A) * f,
            Color.b(A) * f
        );
    }
    static MulScalar_mem(A:number, f:number, C?:number):number {
        if(C){
            Color.r(C) = Color.r(A) * f;
            Color.g(C) = Color.g(A) * f;
            Color.b(C) = Color.b(A) * f;
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Color.r(A) * f,
                Color.g(A) * f,
                Color.b(A) * f
            );
        }
    }

    static DivScalar(A:RGBA, f:number):RGB { return rgb(A.r / f, A.g / f, A.b / f); }
    static DivScalar_mem(A:number, f:number, C?:number):number {
        if(C){
            Color.r(C) = Color.r(A) / f;
            Color.g(C) = Color.g(A) / f;
            Color.b(C) = Color.b(A) / f;
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Color.r(A) / f,
                Color.g(A) / f,
                Color.b(A) / f
            );
        }
    }

    static Min(A:RGBA, b:RGBA):RGB { return rgb( Math.min(A.r , b.r), Math.min(A.g , b.g), Math.min(A.b , b.b) ); }
    static Min_mem(A:number, b:number, C?:number):number {
        if(C){
            Color.r(C) = Math.min(Color.r(A) , Color.r(b));
            Color.g(C) = Math.min(Color.g(A) , Color.g(b));
            Color.b(C) = Math.min(Color.b(A) , Color.b(b));
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Math.min(Color.r(A) , Color.r(b)),
                Math.min(Color.g(A) , Color.g(b)),
                Math.min(Color.b(A) , Color.b(b))
            );
        }
    }

    static Max(A:RGBA, b:RGBA):RGB {return rgb( Math.max(A.r , b.r), Math.max(A.g , b.g), Math.max(A.b , b.b) );}
    static Max_mem(A:number, b:number, C?:number):number {
        if(C){
            Color.r(C) = Math.max(Color.r(A) , Color.r(b));
            Color.g(C) = Math.max(Color.g(A) , Color.g(b));
            Color.b(C) = Math.max(Color.b(A) , Color.b(b));
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Math.max(Color.r(A) , Color.r(b)),
                Math.max(Color.g(A) , Color.g(b)),
                Math.max(Color.b(A) , Color.b(b))
            );
        }
    }

    static MinComponent(A:RGBA):number {return Math.min(Math.min(A.r, A.g), A.b)}
    static MinComponent_mem(A:number) {
        return Math.min( Math.min(Color.r(A), Color.g(A)), Color.b(A) );
    }

    static MaxComponent(A:RGBA):number { return Math.max(Math.max(A.r, A.g), A.b) }
    static MaxComponent_mem(A:number):number {
        return Math.max( Math.max(Color.r(A), Color.g(A)), Color.b(A) );
    }

    static Pow(A:RGBA, f:number):RGB {return rgb( Math.pow(A.r, f), Math.pow(A.g, f), Math.pow(A.b, f) );}
    static Pow_mem(A:number, f:number, C?:number):number {
        if(C){
            Color.r(C) = Math.pow(Color.r(A) , f);
            Color.g(C) = Math.pow(Color.g(A) , f);
            Color.b(C) = Math.pow(Color.b(A) , f);
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Math.pow(Color.r(A) , f),
                Math.pow(Color.g(A) , f),
                Math.pow(Color.b(A) , f)
            );
        }
    }

    static Mix(A:RGBA, b:RGBA, pct:number):RGB {
        let _a = Color.MulScalar(A, 1 - pct);
        let _b = Color.MulScalar(b, pct);
        return rgb(_a.r + _b.r, _a.g + _b.g, _a.b + _b.b);
    }
    static Mix_mem(A:number, b:number, pct:number, C?:number):number {

        let _a:number = Color.MulScalar_mem(A, 1 - pct);
        let _b:number = Color.MulScalar_mem(b, pct);

        if(C){
            Color.r(C) = Color.r(_a) + Color.r(_b);
            Color.g(C) = Color.g(_a) + Color.g(_b);
            Color.b(C) = Color.b(_a) + Color.b(_b);
            return C;
        }else{
            let ptr:number = @new Color;
            return Color.Init_mem(
                ptr,
                Color.r(_a) + Color.r(_b),
                Color.g(_a) + Color.g(_b),
                Color.b(_a) + Color.b(_b)
            );
        }
    }

    static IsEqual(A:number, b:number):boolean{
        return Color.r(A) === Color.r(b) && Color.g(A) === Color.g(b) && Color.b(A) === Color.b(b);
    }

    static IsBlack(A:number):boolean{
        return Color.IsEqual(A, Color.BLACK);
    }

    static IsWhite(A:number):boolean{
        return Color.IsEqual(A, Color.WHITE);
    }
    static Set(SELF:number, r:number, g:number, b:number) {
        SELF.r = r;
        SELF.g = g;
        SELF.b = b;
        return SELF;
    }

    static Clone(SELF:number, c?:number):number {
        let ptr:number = c?c:@new Color;
        return Color.Init_mem(ptr, SELF.r, SELF.g, SELF.b);
    }

    static get BLACK():number{
        return Color.HexColor(0x000000);
    }
    static get WHITE():number {
        return Color.HexColor(0xFFFFFF);
    }

    static BrightColors = [
        Color.HexColor(0xFF00FF),
        Color.HexColor(0x84FF00),
        Color.HexColor(0xFF0084),
        Color.HexColor(0x00FFFF),
        Color.HexColor(0x00FF84),
        Color.HexColor(0xDD40FF),
        Color.HexColor(0xFFFF00)
    ];

    static RGBAColors = [
        Color.HexColor(0xFF0000),
        Color.HexColor(0x00FF00),
        Color.HexColor(0x0000FF),
        Color.HexColor(0xFFFFFF)
    ];

    static Random():number {
        let ptr:number = @new Color;
        return Color.Init_mem(ptr, Math.random(), Math.random(), Math.random());
    }

    static random():RGB {
        return rgb(Math.random(), Math.random(), Math.random());
    }

    static RandomBrightColor():number {
        var i:number = Math.round(Math.random() * Color.BrightColors.length);
        return Color.BrightColors[i];
    }

    static RandomRGBAColor():number {
        var i:number = Math.round(Math.random() * Color.RGBAColors.length);
        return Color.RGBAColors[i];
    }

    static toColor3(SELF){
        return new Color3(SELF.r, SELF.g, SELF.b);
    }

} @end

