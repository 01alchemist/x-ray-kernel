@turbo  class Triangle{
	V1:int32
    V2:int32
    V3:int32
    N1:int32
    N2:int32
    N3:int32
    T1:int32
    T2:int32
    T3:int32
    Material:int32

    @method init(SELF, v1:number=-1, v2:number=-1, v3:number=-1, n1:number=-1, n2:number=-1, n3:number=-1, t1:number=-1, t2:number=-1, t3:number=-1, material:number=-1){
        SELF.V1 = v1;
        SELF.V2 = v2;
        SELF.V3 = v3;
        SELF.N1 = n1;
        SELF.N2 = n2;
        SELF.N3 = n3;
        SELF.T1 = t1;
        SELF.T2 = t2;
        SELF.T3 = t3;
        SELF.Material = material;
		return SELF;
	}

	static NewTriangle(v1:number, v2:number, v3:number, t1:number, t2:number, t3:number, material:number):number {
		let SELF = @new Triangle;
		SELF.V1 = v1;
		SELF.V2 = v2;
		SELF.V3 = v3;
		SELF.T1 = t1;
		SELF.T2 = t2;
		SELF.T3 = t3;
		SELF.Material = material;
		SELF.FixNormals();
		return SELF;
	}

    static Vertices(SELF){
		return {
            V1:SELF.V1,
            V2:SELF.V2,
            V3:SELF.V3
        }
	}

	static Compile() {
	}

    static BoundingBox(SELF):number{
		let min = Vector.Min_mem(Vector.Min_mem(SELF.V1, SELF.V2), SELF.V3);
		let max = Vector.Max_mem(Vector.Max_mem(SELF.V1, SELF.V2), SELF.V3);
        let ptr:number = @new Box;
		return Box.Init_mem(ptr, min, max);
	}

	static Intersect(SELF, r:number /*Ray*/):Hit {

        let dir = Ray.Direction(r);
        let org = Ray.Origin(r);

		let e1x = Vector.X(SELF.V2) - Vector.X(SELF.V1);
        let e1y = Vector.Y(SELF.V2) - Vector.Y(SELF.V1);
        let e1z = Vector.Z(SELF.V2) - Vector.Z(SELF.V1);
        let e2x = Vector.X(SELF.V3) - Vector.X(SELF.V1);
        let e2y = Vector.Y(SELF.V3) - Vector.Y(SELF.V1);
        let e2z = Vector.Z(SELF.V3) - Vector.Z(SELF.V1);
        let px = Vector.Y(dir) * e2z - Vector.Z(dir) * e2y;
        let py = Vector.Z(dir) * e2x - Vector.X(dir) * e2z;
        let pz = Vector.X(dir) * e2y - Vector.Y(dir) * e2x;
		let det = e1x * px + e1y * py + e1z * pz;
		if (det > -EPS && det < EPS) {
			return Hit.NoHit;
		}
		let inv = 1 / det;
        let tx = Vector.X(org) - Vector.X(SELF.V1);
        let ty = Vector.Y(org) - Vector.Y(SELF.V1);
        let tz = Vector.Z(org) - Vector.Z(SELF.V1);
        let u = (tx * px + ty * py + tz * pz) * inv;
		if (u < 0 || u > 1) {
			return Hit.NoHit
		}
        let qx = ty * e1z - tz * e1y;
        let qy = tz * e1x - tx * e1z;
        let qz = tx * e1y - ty * e1x;
        let v = (Vector.X(dir) * qx + Vector.Y(dir) * qy + Vector.Z(dir) * qz) * inv;
		if (v < 0 || u+v > 1) {
			return NoHit
		}
        let d = (e2x*qx + e2y*qy + e2z*qz) * inv;
		if (d < EPS) {
			return NoHit
		}
		return new Hit(SELF, d, null);
	}

	static UV(SELF, p:number/*Vector*/):number /*Vector*/ {
        let uvw = Triangle.Barycentric(SELF, p);
		let n = @new Vector;
		n = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.T1, uvw.u), n);
		n = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.T2, uvw.v), n);
		n = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.T3, uvw.w), n);
        Vector.Z(n) = 0;
		return n
	}

	static MaterialAt(SELF, p:number /*Vector*/):number /*Material*/ {
		return SELF.Material;
	}

	static NormalAt(SELF, p:number /*Vector*/):number /*Vector*/ {
		let uvw = Triangle.Barycentric(p);
		let n = @ new Vector;
        n = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.N1, uvw.u), n);
        n = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.N2, uvw.v), n);
        n = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.N3, uvw.w), n);
		n = Vector.Normalize_mem(n);
		if (Material.NormalTexture(SELF.Material) != null) {
			let b = @new Vector;
            b = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.T1, uvw.u), b);
            b = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.T2, uvw.v), b);
            b = Vector.Add_mem(n, Vector.MulScalar_mem(SELF.T3, uvw.w), b);

			let ns = Texture.NormalSample(Material.NormalTexture(SELF.Material), b.X, b.Y);
			let dv1 = Vector.Sub_mem(SELF.V2, SELF.V1);
            let dv2 = Vector.Sub_mem(SELF.V3, SELF.V1);
            let dt1 = Vector.Sub_mem(SELF.T2, SELF.T1);
            let dt2 = Vector.Sub_mem(SELF.T3, SELF.T1);

			let T = Vector.Normalize_mem(Vector.Sub_mem(Vector.MulScalar_mem(dv1, Vector.Y(dt2)), Vector.MulScalar_mem(dv2, Vector.Y(dt1))));
            let B = Vector.Normalize_mem(Vector.Sub_mem(Vector.MulScalar_mem(dv2, Vector.X(dt1)), Vector.MulScalar_mem(dv1, Vector.X(dt2))));
            let N = Vector.Cross_mem(T, B);
			let matrix = @new Matrix;
			Matrix.init(matrix,
					Vector.X(T), Vector.X(B), Vector.X(N), 0,
					Vector.Y(T), Vector.Y(B), Vector.Y(N), 0,
					Vector.Z(T), Vector.Z(B), Vector.Z(N), 0,
					0, 0, 0, 1);
			n = Matrix.MulDirection(matrix, ns);
		}
		if (Material.BumpTexture(SELF.Material) != null) {
			let b = @new Vector;
			b = Vector.Add_mem(b, Vector.MulScalar_mem(SELF.T1, uvw.u), b);
			b = Vector.Add_mem(b, Vector.MulScalar_mem(SELF.T2, uvw.v), b);
			b = Vector.Add_mem(b, Vector.MulScalar_mem(SELF.T3, uvw.w), b);
			let bump = Texture.BumpSample(Material.BumpTexture(SELF.Material), Vector.X(b), Vector.Y(b));
			let dv1 = Vector.Sub_mem(SELF.V2, SELF.V1);
			let dv2 = Vector.Sub_mem(SELF.V3, SELF.V1);
			let dt1 = Vector.Sub_mem(SELF.T2, SELF.T1);
			let dt2 = Vector.Sub_mem(SELF.T3, SELF.T1);
			let tangent = Vector.Normalize_mem(Vector.Sub_mem(Vector.MulScalar_mem(dv1, Vector.Y(dt2)), Vector.MulScalar_mem(dv2, Vector.Y(dt1))));
			let bitangent = Vector.Sub_mem(Vector.Normalize_mem(Vector.MulScalar_mem(dv2, Vector.X(dt1)), Vector.MulScalar_mem(dv1, Vector.X(dt2))));
			n = Vector.Add_mem(n, Vector.MulScalar_mem(tangent, Vector.X(bump) * Material.BumpMultiplier(SELF.Material)), n);
			n = Vector.Add_mem(n, Vector.MulScalar_mem(bitangent, Vector.Y(bump) * Material.BumpMultiplier(SELF.Material)), n);
		}
		n = Vector.Normalize_mem(n, n);
		return n;
	}

	static Area(SELF):number {
		let e1 = Vector.Sub_mem(SELF.V2, SELF.V1);
		let e2 = Vector.Sub_mem(SELF.V3, SELF.V1);
		let n = Vector.Cross_mem(e1, e2);
		return Vector.Length_mem(n) / 2;
	}

	static Barycentric(SELF, p:number /*Vector*/):{u:number, v:number, w:number} {
		let v0 = Vector.Sub_mem(SELF.V2, SELF.V1);
		let v1 = Vector.Sub_mem(SELF.V3, SELF.V1);
		let v2 = Vector.Sub_mem(p, SELF.V1);
		let d00 = Vector.Dot_mem(v0, v0);
		let d01 = Vector.Dot_mem(v0, v1);
		let d11 = Vector.Dot_mem(v1, v1);
		let d20 = Vector.Dot_mem(v2, v0);
		let d21 = Vector.Dot_mem(v2, v1);
		let d = d00*d11 - d01*d01;
		let v = (d11*d20 - d01*d21) / d;
		let w = (d00*d21 - d01*d20) / d;
		let u = 1 - v - w;
		return {u:u,v:v,w:w};
	}

	static FixNormals(SELF) {
		let e1 = Vector.Sub_mem(SELF.V2, SELF.V1);
		let e2 = SELF.V3.Sub(SELF.V1);
		let n = Vector.Normalize_mem(Vector.Cross_mem(e1, e2));

        if(Vector.IsZero(SELF.N1)) {
            SELF.N1 = n;
        }
        if(Vector.IsZero(SELF.N2)) {
            SELF.N2 = n;
        }
        if(Vector.IsZero(SELF.N3)) {
            SELF.N3 = n;
        }
	}

} @end
