@turbo class Sphere extends Shape{
	Center:Vector
	Radius:float64
	Material:Material
	Box:Box

	@method init(SELF, center:number, radius:number, material:number, box:number):number{
		SELF.Center = center;
		SELF.Radius = radius;
		SELF.Material = material;
		SELF.Box = box;
		return SELF;
	}

	static NewSphere(center:number, radius:number, material:number):number {
		let min = @new Vector;
		let max = @new Vector;
		Vector.Init_mem(min, Vector.X(center) - radius, Vector.Y(center) - radius, Vector.Z(center) - radius);
		Vector.Init_mem(max, Vector.X(center) + radius, Vector.Y(center) + radius, Vector.Z(center) + radius);
		let box = @new Box;
		Box.Init_mem(box , min, max);
		let ptr:number = @new Sphere;
		return Sphere.init(ptr, center, radius, material, box);
	}

	@virtual Type(SELF){
		return ShapeType.SPHERE;
	}

	@virtual ToJSON(SELF){
		return {
			center:Vector.ToJSON(SELF.Center),
			radius:SELF.Radius,
			material:Material.ToJSON(SELF.Material),
			box:Box.ToJSON(SELF.Box),
		}
	}

	@virtual Compile(SELF) {
	}

	@virtual BoundingBox(SELF):number {
		return SELF.Box;
	}

	@virtual Intersect(SELF, r:number):Hit {
		let to = Vector.Sub_mem(Ray.Origin(r), SELF.Center);
		let b = Vector.Dot_mem(to, Ray.Direction(r));
		let c = Vector.Dot_mem(to, to) - SELF.Radius * SELF.Radius;
		let d = b * b - c;
		if (d > 0) {
			d = Math.sqrt(d);
			let t1 = -b - d;
			if (t1 > EPS) {
				return new Hit(SELF, t1, null)
			}
			let t2 = -b + d;
			if (t2 > EPS) {
				return new Hit(SELF, t2, null);
			}
		}
		return Hit.NoHit;
	}

	@virtual UV(SELF, p:number):number {
		p = Vector.Sub_mem(p, SELF.Center);
		let u = Math.atan2(Vector.Z(p), Vector.X(p));
		let ptr=@new Vector;
		let l = Vector.Length_mem(Vector.Init_mem(ptr, Vector.X(p), 0, Vector.Z(p)));
		let v = Math.atan2(Vector.Y(p), l);
		u = 1 - (u+Math.PI)/(2*Math.PI);
		v = (v + Math.PI/2) / Math.PI;
		return Vector.Init_mem(ptr, u, v, 0);
	}

	@virtual MaterialAt(SELF, p:number):number {
		return SELF.Material;
	}

	@virtual NormalAt(SELF, p:number):number {
		return Vector.Normalize_mem(Vector.Sub_mem(p, SELF.Center));
	}

} @end