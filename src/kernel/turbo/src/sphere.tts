@turbo class Sphere {
	Center:int32
	Radius:float64
	Material:int32
	Box:int32

	@method init(SELF, center:number, radius:number, material:number, box:number):number{
		SELF.Center = center;
		SELF.Radius = radius;
		SELF.material = material;
		SELF.Box = box;
		return SELF;
	}

	static NewSphere(center:number, radius:number, material:number):number {
		let min = @new Vector;
		let max = @new Vector;
		Vector.Init_mem(min, Vector.X(center) - radius, Vector.Y(center) - radius, Vector.Z(center) - radius);
		Vector.Init_mem(max, Vector.X(center) + radius, Vector.Y(center) + radius, Vector.Z(center) + radius);
		let box = @new Box;
		Box.Init_mem(box , min, max);
		let ptr:number = @new Sphere;
		return Sphere.init(ptr, center, radius, material, box);
	}

	Compile() {
	}

	static BoundingBox(SELF):number {
		return SELF.Box;
	}

	static Intersect(SELF, r:number):Hit {
		let to = Vector.Sub_mem(Ray.Origin(r), SELF.Center);
		let b = Vector.Dot_mem(to, Ray.Direction(r));
		let c = Vector.Dot_mem(to, to) - SELF.Radius * SELF.Radius;
		let d = b * b - c;
		if (d > 0) {
			d = Math.sqrt(d);
			let t1 = -b - d;
			if (t1 > EPS) {
				return new Hit(SELF, t1, null)
			}
			let t2 = -b + d;
			if (t2 > EPS) {
				return new Hit(SELF, t2, null);
			}
		}
		return Hit.NoHit;
	}

	static UV(SELF, p:number):number {
		p = Vector.Sub_mem(p, SELF.Center);
		let u = Math.atan2(Vector.Z(p), Vector.X(p));
		let ptr=@new Vector;
		let l = Vector.Length_mem(Vector.Init_mem(ptr, Vector.X(p), 0, Vector.Z(p)));
		let v = Math.atan2(Vector.Y(p), l);
		u = 1 - (u+Math.PI)/(2*Math.PI);
		v = (v + Math.PI/2) / Math.PI;
		return Vector.Init_mem(ptr, u, v, 0);
	}

	static MaterialAt(SELF, p:number):number {
		return SELF.Material;
	}

	static NormalAt(SELF, p:number):number {
		return Vector.Normalize_mem(Vector.Sub_mem(p, SELF.Center));
	}

} @end