interface RGBA {
    R:number,
    G:number,
    B:number,
    A:number
}

@turbo:: class Color{

	R:float64;
	G:float64;
	B:float64;

	@method init(SELF:number, color = {R:0,G:0,B:0}):number {
		SELF.R = color.R;
		SELF.G = color.G;
		SELF.B = color.B;
		return SELF;
	}

	static HexColor(hex:number):number {
		let R = ((hex >> 16) & 255 ) / 255;
		let G = ((hex >> 8) & 255) / 255;
		let B = (hex & 255) / 255;
        let c = RGB(R, G, B);
        let new_ptr:number = @new Color;
		return Color.Pow_mem(Color.init(new_ptr, c), 2.2);
	}

    static Kelvin(K:number):number {
        var red:number;
        var green:number;
        var blue:number;
        // red
        if(K >= 6600){
            var A = 351.97690566805693;
            var B = 0.114206453784165;
            var c = -40.25366309332127;
            var x = K/100 - 55;
            red = A + B*x + c*Math.log(x)
        } else {
            red = 255;
        }
        // green
        if(K >= 6600){
            A = 325.4494125711974;
            B = 0.07943456536662342;
            c = -28.0852963507957;
            x = K/100 - 50;
            green = A + B*x + c*Math.log(x)
        } else if (K >= 1000) {
            A = -155.25485562709179;
            B = -0.44596950469579133;
            c = 104.49216199393888;
            x = K/100 - 2;
            green = A + B*x + c*Math.log(x)
        } else {
            green = 0
        }
        // blue
        if (K >= 6600) {
            blue = 255
        } else if (K >= 2000) {
            A = -254.76935184120902;
            B = 0.8274096064007395;
            c = 115.67994401066147;
            x = K/100 - 10;
            blue = A + B*x + c*Math.log(x)
        } else {
            blue = 0
        }
        red = Math.min(1, red/255);
        green = Math.min(1, green/255);
        blue = Math.min(1, blue/255);
        return Color.init(@new Color, RGB(red, green, blue));
    }

    @method RGBA(SELF:number):RGBA {
        let _c:Uint8Array = new Uint8Array(3);
        _c[0] = Math.max(0, Math.min(255, Color.R(SELF) * 255));
        _c[1] = Math.max(0, Math.min(255, Color.G(SELF) * 255));
        _c[2] = Math.max(0, Math.min(255, Color.B(SELF) * 255));
        return {R: _c[0], G: _c[1], B: _c[2], A: 255};
    }

    @method RGBA64(SELF:number):RGBA {
        let _c:Uint16Array = new Uint16Array(3);
        _c[0] = Math.max(0, Math.min(65535, Color.R(SELF) * 65535));
        _c[1] = Math.max(0, Math.min(65535, Color.G(SELF) * 65535));
        _c[2] = Math.max(0, Math.min(65535, Color.B(SELF) * 65535));
        return {R: _c[0], G: _c[1], B: _c[2], A: 65535};
    }
    
    static Add(A:RGBA, B:RGBA){return RGB(A.R + B.R, A.G + B.G, A.B + B.B);}

    static Add_mem(A:number, B:number, C?:number){
        //C = C?C:Color.init(@new Color);
        if(C){
            C = C;
        }else{
            return Color.init(@new Color, RGB(Color.R(A) + Color.R(B), Color.G(A) + Color.G(B), Color.B(A) + Color.B(B)));
        }
        // return RGB(Color.R(A) + Color.R(B), Color.G(A) + Color.G(B), Color.B(A) + Color.B(B));
    }

    static Sub(A:RGBA, B:RGBA){return RGB(A.R - B.R, A.G - B.G, A.B - B.B);}
    static Sub_mem(A:number, B:number){
        return RGB(Color.R(A) - Color.R(B), Color.G(A) - Color.G(B), Color.B(A) - Color.B(B));
    }
    
    static Mul(A:RGBA, B:RGBA){return RGB(A.R * B.R, A.G * B.G, A.B * B.B);}
    static Mul_mem(A:number, B:number) {
        return RGB(Color.R(A) * Color.R(B), Color.G(A) * Color.G(B), Color.B(A) * Color.B(B));
    }

    static MulScalar(A:RGBA, f:number){return RGB(A.R * f, A.G * f, A.B * f);}
    static MulScalar_mem(A:number, f:number) {
        return RGB(Color.R(A) * f, Color.G(A) * f, Color.B(A) * f);
    }

    static DivScalar(A:RGBA, f:number){return RGB(A.R / f, A.G / f, A.B / f);}
    static DivScalar_mem(A:number, f:number) {
        return RGB(Color.R(A) / f, Color.G(A) / f, Color.B(A) / f);
    }

    static Min(A:RGBA, B:RGBA) {return RGB( Math.min(A.R , B.R), Math.min(A.G , B.G), Math.min(A.B , B.B) );}
    static Min_mem(A:number, B:number) {
        return RGB( Math.min(Color.R(A) , Color.R(B)), Math.min(Color.G(A) , Color.G(B)), Math.min(Color.B(A) , Color.B(B)) );
    }

    static Max(A:RGBA, B:RGBA){return RGB( Math.max(A.R , B.R), Math.max(A.G , B.G), Math.max(A.B , B.B) );}
    static Max_mem(A:number, B:number){
        return RGB( Math.max(Color.R(A) , Color.R(B)), Math.max(Color.G(A) , Color.G(B)), Math.max(Color.B(A) , Color.B(B)) );
    }

    static MinComponent(A:RGBA):number {return Math.min(Math.min(A.R, A.G), A.B)}
    static MinComponent_mem(A:number) {
        return Math.min( Math.min(Color.R(A), Color.G(A)), Color.B(A) );
    }

    static MaxComponent(A:RGBA){ return Math.max(Math.max(A.R, A.G), A.B) }
    static MaxComponent_mem(A:number){
        return Math.max( Math.max(Color.R(A), Color.G(A)), Color.B(A) );
    }

    static Pow(A:RGBA, f:number) {return RGB( Math.pow(A.R, f), Math.pow(A.G, f), Math.pow(A.B, f) );}
    static Pow_mem(A:number, f:number) {
        let SELF = @new Color;
        SELF.R = Math.pow(Color.R(A), f);
        SELF.G = Math.pow(Color.G(A), f);
        SELF.B = Math.pow(Color.B(A), f);
        return SELF;
    }

    static Mix(A:RGBA, B:RGBA, pct:number) {
        let _a = Color.MulScalar(A, 1 - pct);
        let _b = Color.MulScalar(B, pct);
        return RGB(_a.R + _b.R, _a.G + _b.G, _a.B + _b.B);
    }
    static Mix_mem(A:number, B:number, pct:number) {
        let _a = Color.MulScalar_mem(A, 1 - pct);
        let _b = Color.MulScalar_mem(B, pct);
        return RGB(_a.R + _b.R, _a.G + _b.G, _a.B + _b.B);
    }

    @method set(SELF, r:number, g:number, b:number) {
        SELF.R = r;
        SELF.G = g;
        SELF.B = b;
        return SELF;
    }

    @method Clone(SELF):number {
        return Color.init(SELF, RGB(SELF.R, SELF.G, SELF.B));
    }


    static NewColor(color):number {
        return Color.init(@new Color, color);
    }

    static BrightColors = [
        Color.HexColor(0xFF00FF),
        Color.HexColor(0x84FF00),
        Color.HexColor(0xFF0084),
        Color.HexColor(0x00FFFF),
        Color.HexColor(0x00FF84),
        Color.HexColor(0xDD40FF),
        Color.HexColor(0xFFFF00)
    ];

    static Random():number {
        return Color.NewColor(RGB(Math.random(), Math.random(), Math.random()));
    }

    static RandomBrightColor():number {
        var i:number = Math.round(Math.random() * Color.BrightColors.length);
        return Color.BrightColors[i];
    }

} @end