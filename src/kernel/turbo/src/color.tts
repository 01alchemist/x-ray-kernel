interface RGBA {
    R:number,
    G:number,
    B:number,
    A:number
}

@turbo:: class Color{

	R:float64;
	G:float64;
	B:float64;

	@method init(SELF, color){
		SELF.R = color.R;
		SELF.G = color.G;
		SELF.B = color.B;
		return SELF;
	};

	@method HexColor(SELF, hex:number):number {
		var R = ((hex >> 16) & 255 ) / 255;
		var G = ((hex >> 8) & 255) / 255;
		var B = (hex & 255) / 255;
		return Color.Pow(Color.init(SELF, RGB(R, G, B)), 2.2);
	};

	@method Kelvin(SELF, K:number):number {
        var red:number;
        var green:number;
        var blue:number;
        // red
        if(K >= 6600){
            var A = 351.97690566805693;
            var B = 0.114206453784165;
            var c = -40.25366309332127;
            var x = K/100 - 55;
            red = A + B*x + c*Math.log(x)
        } else {
            red = 255;
        }
        // green
        if(K >= 6600){
            A = 325.4494125711974;
            B = 0.07943456536662342;
            c = -28.0852963507957;
            x = K/100 - 50;
            green = A + B*x + c*Math.log(x)
        } else if (K >= 1000) {
            A = -155.25485562709179;
            B = -0.44596950469579133;
            c = 104.49216199393888;
            x = K/100 - 2;
            green = A + B*x + c*Math.log(x)
        } else {
            green = 0
        }
        // blue
        if (K >= 6600) {
            blue = 255
        } else if (K >= 2000) {
            A = -254.76935184120902;
            B = 0.8274096064007395;
            c = 115.67994401066147;
            x = K/100 - 10;
            blue = A + B*x + c*Math.log(x)
        } else {
            blue = 0
        }
        red = Math.min(1, red/255);
        green = Math.min(1, green/255);
        blue = Math.min(1, blue/255);
        return Color.init(SELF, RGB(red, green, blue));
    };

    @method NewColor(SELF, c:RGBA):number {
        return Color.init(SELF, RGB(c.R / 65535, c.G / 65535, c.B / 65535));
    };

    @method RGBA(SELF:number):RGBA {
        let _c:Uint8Array = new Uint8Array(3);
        _c[0] = Math.max(0, Math.min(255, Color.R(SELF) * 255));
        _c[1] = Math.max(0, Math.min(255, Color.G(SELF) * 255));
        _c[2] = Math.max(0, Math.min(255, Color.B(SELF) * 255));
        return {R: _c[0], G: _c[1], B: _c[2], A: 255};
    };

    @method RGBA64(SELF:number):RGBA {
        let _c:Uint16Array = new Uint16Array(3);
        _c[0] = Math.max(0, Math.min(65535, Color.R(SELF) * 65535));
        _c[1] = Math.max(0, Math.min(65535, Color.G(SELF) * 65535));
        _c[2] = Math.max(0, Math.min(65535, Color.B(SELF) * 65535));
        return {R: _c[0], G: _c[1], B: _c[2], A: 65535};
    };
    
    Color.Add = function(A:Color, B:Color){return RGB(A.R + B.R, A.G + B.G, A.B + B.B);};
    Color.Add_mem = function(A:number, B:number){
        return RGB(Color.R(A) + Color.R(B), Color.G(A) + Color.G(B), Color.B(A) + Color.B(B));
    };
    
    Color.Sub = function(A:Color, B:Color){return RGB(A.R - B.R, A.G - B.G, A.B - B.B);};
    Color.Sub_mem = function(A:number, B:number){
        return RGB(Color.R(A) - Color.R(B), Color.G(A) - Color.G(B), Color.B(A) - Color.B(B));
    };
    
    Color.Mul = function(A:Color, B:Color){return RGB(A.R * B.R, A.G * B.G, A.B * B.B);};
    Color.Mul_mem = function(A:number, B:number) {
        return RGB(Color.R(A) * Color.R(B), Color.G(A) * Color.G(B), Color.B(A) * Color.B(B));
    };

    Color.MulScalar = function(A:Color, f:number){return RGB(A.R * f, A.G * f, A.B * f);};
    Color.MulScalar_mem = function(A:number, f:number) {
        return RGB(Color.R(A) * f, Color.G(A) * f, Color.B(A) * f);
    };

    Color.DivScalar = function(A:Color, f:number){return RGB(A.R / f, A.G / f, A.B / f);};
    Color.DivScalar_mem = function(A:number, f:number) {
        return RGB(Color.R(A) / f, Color.G(A) / f, Color.B(A) / f);
    };

    Color.Min = function(A:Color, B:Color) {return RGB( Math.min(A.R , B.R), Math.min(A.G , B.G), Math.min(A.B , B.B) );};
    Color.Min_mem = function(A:number, B:number) {
        return RGB( Math.min(Color.R(A) , Color.R(B)), Math.min(Color.G(A) , Color.G(B)), Math.min(Color.B(A) , Color.B(B)) );
    };

    Color.Max = function(A:Color, B:Color){return RGB( Math.max(A.R , B.R), Math.max(A.G , B.G), Math.max(A.B , B.B) );};
    Color.Max_mem = function(A:number, B:number){
        return RGB( Math.max(Color.R(A) , Color.R(B)), Math.max(Color.G(A) , Color.G(B)), Math.max(Color.B(A) , Color.B(B)) );
    };

    Color.MinComponent = function(A:Color, B:Color):number {return Math.min(Math.min(A.R, A.G), A.B)};
    Color.MinComponent_mem = function(A:number, B:number) {
        return Math.min( Math.min(Color.R(A.R), Color.G(A.G)), Color.B(A.B) );
    };

    Color.MaxComponent = function(A:Color, B:Color){ return Math.max(Math.max(A.R, A.G), A.B) };
    Color.MaxComponent_mem = function(A:number, B:number){
        return Math.max( Math.max(Color.R(A.R), Color.G(A.G)), Color.B(A.B) );
    };

    Color.Pow = function(A:Color, f:number) {return RGB( Math.pow(A.R, f), Math.pow(A.G, f), Math.pow(A.B, f) );};
    Color.Pow_mem = function(A:number, f:number) {
        return RGB( Math.pow(Color.R(A), f), Math.pow(Color.G(A), f), Math.pow(Color.B(A), f) );
    };

    Color.Mix = function(A:Color, B:Color, pct:number) {
        let _a = Color.MulScalar(A, 1 - pct);
        let _b = Color.MulScalar(B, pct);
        return RGB(_a.R + _b.R, _a.G + _b.G, _a.B + _b.B);
    };
    Color.Mix_mem = function(A:number, B:number, pct:number) {
        let _a = Color.MulScalar_mem(A, 1 - pct);
        let _b = Color.MulScalar_mem(B, pct);
        return RGB(_a.R + _b.R, _a.G + _b.G, _a.B + _b.B);
    };

    @method set(SELF, r:number, g:number, b:number) {
        SELF.r = r;
        SELF.g = g;
        SELF.b = b;
        return SELF;
    };

    @method Clone(SELF):number {
        return Color.init(SELF, RGB(SELF.r, SELF.g, SELF.b));
    };

    Color.BrightColors = [
        Color.HexColor(0xFF00FF),
        Color.HexColor(0x84FF00),
        Color.HexColor(0xFF0084),
        Color.HexColor(0x00FFFF),
        Color.HexColor(0x00FF84),
        Color.HexColor(0xDD40FF),
        Color.HexColor(0xFFFF00)
    ];

    Color.Random = function():Color {
        return new Color(Math.random(), Math.random(), Math.random());
    };

    Color.RandomBrightColor = function():Color {
        var i:number = Math.round(Math.random() * Color.brightColors.length);
        return Color.brightColors[i];
    };

} @end